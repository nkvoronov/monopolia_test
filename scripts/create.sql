USE master;
GO

IF DB_ID('MonopoliaTest') IS NOT NULL
  DROP DATABASE MonopoliaTest;
GO

CREATE DATABASE MonopoliaTest
ON PRIMARY (NAME = MonopoliaTest_dat,
  FILENAME = 'D:\DB\MSSQL\MonopoliaTest\MonopoliaTest.mdf')
LOG ON (NAME = MonopoliaTest_log,
  FILENAME = 'D:\DB\MSSQL\MonopoliaTest\MonopoliaTest.ldf');
GO 

use MonopoliaTest;
GO

/***   Создание таблиц базы данных ***/

     /*** Справочник клиентов ***/
CREATE TABLE CLIENTS
( ID          INTEGER IDENTITY(1,1) NOT NULL, /* Код клиента */
  NAME        VARCHAR(100) NOT NULL,          /* Название клиента */
  CONSTRAINT PK_CLIENTS 
	PRIMARY KEY (ID)                          /* Первичный ключ */
);

     /*** Справочник товаров ***/
CREATE TABLE GOODS
( ID          INTEGER IDENTITY(1,1) NOT NULL, /* Код товара */
  NAME        VARCHAR(100) NOT NULL,          /* Название товара */
  CONSTRAINT PK_GOODS 
	PRIMARY KEY (ID)                          /* Первичный ключ */
);

     /*** Расход ***/
CREATE TABLE DOCS
( ID          INTEGER IDENTITY(1,1) NOT NULL, /* Код расход */
  DATE_DOCS   DATETIME NOT NULL,              /* Дата расхода */
  CLIENT      INTEGER NOT NULL,               /* Код клиента */
  SUMM        DECIMAL(8,2) DEFAULT 0,         /* Сумма расхода */
  DATE_CREATE DATETIME NOT NULL,              /* Дата создания */
  DATE_POST   DATETIME DEFAULT NULL,          /* Дата проводки */
  POST        CHAR(1) DEFAULT '0',            /* Признак проводки */
  CONSTRAINT PK_DOCS 
	PRIMARY KEY (ID),                         /* Первичный ключ */
  CONSTRAINT FK_DOCS_CLIENTS
    FOREIGN KEY (CLIENT) REFERENCES CLIENTS (ID)
);

     /*** Содержимое расхода ***/
CREATE TABLE DOCS_CONTENT
( ID          INTEGER IDENTITY(1,1) NOT NULL, /* Код сод. расхода */
  DOC         INTEGER NOT NULL,               /* Код расход */
  GOOD        INTEGER NOT NULL,               /* Код товра */
  CNT         INTEGER DEFAULT 0,              /* Количество товра */
  PRICE       DECIMAL(8,2) DEFAULT 0,         /* Цена */
  SUMM        DECIMAL(8,2) DEFAULT 0,         /* Сумма */
  CONSTRAINT PK_DOCS_CONTENT 
	PRIMARY KEY (ID),                         /* Первичный ключ */
  CONSTRAINT FK_DOCS_CONTENT_DOCS
    FOREIGN KEY (DOC) REFERENCES DOCS (ID),
  CONSTRAINT FK_DOCS_CONTENT_GOODS
    FOREIGN KEY (GOOD) REFERENCES GOODS (ID)
);

/*** Создание Тригеров ***/

SET ansi_nulls ON 
GO 
SET quoted_identifier ON 
GO 
     /*** Задает дату создания расхода ***/
CREATE TRIGGER DOCS_INSTEAD_INSERT
  ON DOCS INSTEAD OF INSERT
AS
BEGIN
  SET NOCOUNT ON;
  INSERT INTO DOCS (DATE_DOCS, CLIENT, DATE_CREATE) 
	SELECT DATE_DOCS, CLIENT, (CAST(CURRENT_TIMESTAMP AS DATETIME))
	FROM inserted;
END
GO

SET ansi_nulls ON 
GO 
SET quoted_identifier ON 
GO 
     /*** Задает дату проводки расхода ***/
CREATE TRIGGER DOCS_AFTER_UPDATE_DATE_POST
  ON DOCS AFTER UPDATE
AS
IF UPDATE(POST)
BEGIN
  SET NOCOUNT ON;
  DECLARE @POST CHAR(1);
  DECLARE @ID INTEGER;
  DECLARE CUR_POST CURSOR LOCAL FORWARD_ONLY STATIC READ_ONLY FOR SELECT ID, POST FROM inserted;
  OPEN CUR_POST;
  FETCH NEXT FROM CUR_POST INTO @ID, @POST;
  WHILE @@FETCH_STATUS = 0
  BEGIN
	IF @POST = '1'
	BEGIN 
	  UPDATE DOCS SET DATE_POST=CAST(CURRENT_TIMESTAMP AS DATETIME) WHERE ID=@ID;
	  PRINT 'Проведено !!!';
    END
    ELSE
	  UPDATE DOCS SET DATE_POST=NULL WHERE ID=@ID;
	FETCH NEXT FROM CUR_POST INTO @ID, @POST;
  END
  CLOSE CUR_POST;
  DEALLOCATE CUR_POST;
END
GO

SET ansi_nulls ON 
GO 
SET quoted_identifier ON 
GO 
     /*** Удалени содержимого расхода и проверка ***/	 
CREATE TRIGGER DOCS_CONTENT_INSTEAD_DELETE
  ON DOCS_CONTENT INSTEAD OF DELETE
AS
BEGIN
  SET NOCOUNT ON;
  DECLARE @ID INTEGER;
  DECLARE @DOC INTEGER;
  DECLARE @POST CHAR(1);
  DECLARE CUR_CONTENT CURSOR LOCAL FORWARD_ONLY STATIC READ_ONLY FOR SELECT ID, DOC FROM deleted;
  OPEN CUR_CONTENT;
  FETCH NEXT FROM CUR_CONTENT INTO @ID, @DOC;
  WHILE @@FETCH_STATUS = 0
  BEGIN
    SET @POST = (SELECT POST FROM DOCS WHERE ID=@DOC);
	IF @POST = '0'
		DELETE FROM DOCS_CONTENT WHERE ID=@ID;
    ELSE
	  PRINT 'Расход проведен !!!';
	FETCH NEXT FROM CUR_CONTENT INTO @ID, @DOC;
  END
  CLOSE CUR_CONTENT;
  DEALLOCATE CUR_CONTENT;
END
GO

SET ansi_nulls ON 
GO 
SET quoted_identifier ON 
GO 
     /*** Добавление содержимого расхода и проверка ***/
CREATE TRIGGER DOCS_CONTENT_INSTEAD_INSERT
  ON DOCS_CONTENT INSTEAD OF INSERT
AS
BEGIN
  SET NOCOUNT ON;
  DECLARE @DOC INTEGER;
  DECLARE @GOOD INTEGER;
  DECLARE @CNT INTEGER;
  DECLARE @PRICE DECIMAL(8,2);
  DECLARE @POST CHAR(1);
  DECLARE CUR_CONTENT CURSOR LOCAL FORWARD_ONLY STATIC READ_ONLY FOR SELECT DOC, GOOD, CNT, PRICE FROM inserted;
  OPEN CUR_CONTENT;
  FETCH NEXT FROM CUR_CONTENT INTO @DOC, @GOOD, @CNT, @PRICE;
  WHILE @@FETCH_STATUS = 0
  BEGIN
    SET @POST = (SELECT POST FROM DOCS WHERE ID=@DOC);
	IF @POST = '0'
		INSERT INTO DOCS_CONTENT (DOC, GOOD, CNT, PRICE, SUMM) 
			VALUES (@DOC, @GOOD, @CNT, @PRICE, @CNT*@PRICE);
    ELSE
	  PRINT 'Расход проведен !!!';
	FETCH NEXT FROM CUR_CONTENT INTO @DOC, @GOOD, @CNT, @PRICE;
  END
  CLOSE CUR_CONTENT;
  DEALLOCATE CUR_CONTENT;
END	
GO

SET ansi_nulls ON 
GO 
SET quoted_identifier ON 
GO  	 
     /*** Обновление содержимого расхода и проверка ***/
CREATE TRIGGER DOCS_CONTENT_INSTEAD_UPDATE
  ON DOCS_CONTENT INSTEAD OF UPDATE
AS
BEGIN
  SET NOCOUNT ON;
  DECLARE @ID INTEGER;
  DECLARE @DOC INTEGER;
  DECLARE @GOOD INTEGER;
  DECLARE @CNT INTEGER;
  DECLARE @PRICE DECIMAL(8,2);
  DECLARE @POST CHAR(1);
  DECLARE CUR_CONTENT CURSOR LOCAL FORWARD_ONLY STATIC READ_ONLY FOR SELECT ID, DOC, GOOD, CNT, PRICE FROM inserted;
  OPEN CUR_CONTENT;
  FETCH NEXT FROM CUR_CONTENT INTO @ID, @DOC, @GOOD, @CNT, @PRICE;
  WHILE @@FETCH_STATUS = 0
  BEGIN
    SET @POST = (SELECT POST FROM DOCS WHERE ID=@DOC);
	IF @POST = '0'
		UPDATE DOCS_CONTENT SET DOC=@DOC, GOOD=@GOOD, CNT=@CNT, PRICE=@PRICE, SUMM=@CNT*@PRICE WHERE ID=@ID;
    ELSE
	  PRINT 'Расход проведен !!!';
	FETCH NEXT FROM CUR_CONTENT INTO @ID, @DOC, @GOOD, @CNT, @PRICE;
  END
  CLOSE CUR_CONTENT;
  DEALLOCATE CUR_CONTENT;
END
GO 

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
     /*** Подсчет общей суммы расхода при удалении ***/
CREATE TRIGGER DOCS_CONTENT_AFTER_DELETE_SUMM
  ON DOCS_CONTENT AFTER DELETE
AS
BEGIN
  SET NOCOUNT ON;
  DECLARE @DOC INTEGER;
  DECLARE @SUMM DECIMAL(8,2);
  DECLARE CUR_CONTENT CURSOR LOCAL FORWARD_ONLY STATIC READ_ONLY FOR SELECT DOC FROM deleted GROUP BY DOC;
  OPEN CUR_CONTENT;
  FETCH NEXT FROM CUR_CONTENT INTO @DOC;
  WHILE @@FETCH_STATUS = 0
  BEGIN
    SET @SUMM = (SELECT SUM(SUMM) FROM DOCS_CONTENT WHERE DOC=@DOC);
	IF @SUMM IS NOT NULL
		UPDATE DOCS SET SUMM=@SUMM WHERE ID=@DOC;
	ELSE
		UPDATE DOCS SET SUMM=0 WHERE ID=@DOC;
	FETCH NEXT FROM CUR_CONTENT INTO @DOC;
  END
  CLOSE CUR_CONTENT;
  DEALLOCATE CUR_CONTENT;
END
GO

SET ansi_nulls ON 
GO 
SET quoted_identifier ON 
GO 
     /*** Подсчет общей суммы расхода при вставке ***/
CREATE TRIGGER DOCS_CONTENT_AFTER_INSERT_SUMM
  ON DOCS_CONTENT AFTER INSERT
AS
BEGIN
  SET NOCOUNT ON;
  DECLARE @DOC INTEGER;
  DECLARE @SUMM DECIMAL(8,2);
  DECLARE CUR_CONTENT CURSOR LOCAL FORWARD_ONLY STATIC READ_ONLY FOR SELECT DOC FROM inserted GROUP BY DOC;
  OPEN CUR_CONTENT;
  FETCH NEXT FROM CUR_CONTENT INTO @DOC;
  WHILE @@FETCH_STATUS = 0
  BEGIN
    SET @SUMM = (SELECT SUM(SUMM) FROM DOCS_CONTENT WHERE DOC=@DOC);
	IF @SUMM IS NOT NULL
		UPDATE DOCS SET SUMM=@SUMM WHERE ID=@DOC;
	ELSE
		UPDATE DOCS SET SUMM=0 WHERE ID=@DOC;
	FETCH NEXT FROM CUR_CONTENT INTO @DOC;
  END
  CLOSE CUR_CONTENT;
  DEALLOCATE CUR_CONTENT;
END
GO

SET ansi_nulls ON 
GO 
SET quoted_identifier ON 
GO 
     /*** Подсчет общей суммы расхода при обновлении ***/
CREATE TRIGGER DOCS_CONTENT_AFTER_UPDATE_SUMM
  ON DOCS_CONTENT AFTER UPDATE
AS
BEGIN
  SET NOCOUNT ON;
  DECLARE @DOC INTEGER;
  DECLARE @SUMM DECIMAL(8,2);
  DECLARE CUR_CONTENT CURSOR LOCAL FORWARD_ONLY STATIC READ_ONLY FOR SELECT DOC FROM inserted GROUP BY DOC;
  OPEN CUR_CONTENT;
  FETCH NEXT FROM CUR_CONTENT INTO @DOC;
  WHILE @@FETCH_STATUS = 0
  BEGIN
    SET @SUMM = (SELECT SUM(SUMM) FROM DOCS_CONTENT WHERE DOC=@DOC);
	IF @SUMM IS NOT NULL
		UPDATE DOCS SET SUMM=@SUMM WHERE ID=@DOC;
	ELSE
		UPDATE DOCS SET SUMM=0 WHERE ID=@DOC;
	FETCH NEXT FROM CUR_CONTENT INTO @DOC;
  END
  CLOSE CUR_CONTENT;
  DEALLOCATE CUR_CONTENT;
END
GO